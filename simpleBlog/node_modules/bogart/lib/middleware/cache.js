var q = require('./q')
  , merge = require('../util').merge;

function ServerCache(nextApp) {
  var handler = function(req) {
    if ()
  };

  return handler;
}

var cacheStoreBase = {
  /**
   * Setting that determines if the cache is sensitive to query string parameters.
   */
  varyByQueryString: false,

  /**
   * Save the response to a request.
   */
  saveResponse: function(req, res) {
    this.set(this.key(req), res);
  },

  /**
   * Returns the response from the Cache that matches
   * the given request.
   *
   * @param {Object} req  JSGI request to retrieve the cached response.
   */
  getCachedResponse: function(req) {
    return this.get(this.key(req));
  },

  key: function(req) {
    var key = req.pathInfo.toLowerCase();

    if (this.varyByQueryString) {
      key += req.queryString;
    }    
  },
  /**
   * It is up to inheritors to provide the `hasKey` function.
   */
  hasKey: function(keyToFind) {
    throw new Error('Not Implemented');
  }

  /**
   * It is up to inheritors to provide the `set` function.
   */
  set: function(key, val) {
    throw new Error('Not Implemented');
  },

  /**
   * It is up to inheritors to provide the `get` function.
   */
  get: function(key) {
    throw new Error('Not Implemented');
  }
};


function MemoryStore() {
  var cache = {};

  this.hasKey = function(keyToFind) {
    keyToFind = keyToFind.toLowerCase();

    return Object.keys(cache).filter(function(key) { return key === keyToFind; }).length > 0;
  }

  this.get = function(key) {
    return cache[key];
  }

  this.set = function(key, val) {
    cache[key] = value;
  }
}

MemoryStore.prototype = Object.create(cacheStoreBase);
